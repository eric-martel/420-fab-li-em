created: 20210228180229626
modified: 20210228220658562
tags: [[07 Tableaux unidimensionnels (vecteurs)]]
title: 7.02 Adressage et utilisation
type: text/vnd.tiddlywiki

Une fois un tableau défini, on accède aux valeurs qu'il contient par un ''index'', qui correspond à la position de l'élément du tableau, moins un (donc, le 1er élément est à l'index 0, le second élément à l'index 1, etc.); on indique un index avec le nom du tableau, suivi de l'index entre crochets. On peut récupérer une valeur du tableau ou encore la modifier.

!! Exemple 7.2a

```cs
string[] noms = {"Julie", "Marc", "Rachelle", "Jean"};

// Stocke le premier élément du tableau dans la variable «nom1»
string nom1 = noms[0];

// Stocke «Mathieu» comme 2e élément du tableau (remplacera «Marc»)
noms[1] = "Mathieu";
```

Les boucles ''for'' et ''foreach'' sont très utiles pour traiter les éléments d'un tableau; tel que déjà dit à la [[section 4.07|4.07 Quand utiliser quelle boucle?]], on utilisera une boucle ''foreach'' si la position (l'index) des éléments ne nous importe pas, et une boucle ''for'' dans le cas contraire.

!! Exemple 7.2b

```cs
/* Deux tableaux contenant respectivement les noms de personnes
et leur âge respectif (donc Julie a 34 ans, Marc a 27 ans, etc.) */
string[] noms = {"Julie", "Marc", "Rachelle", "Jean"};
int[] ages = {34, 27, 26, 45};

// Affiche seulement les noms: la position ici n'est pas importante => boucle «foreach»
foreach (string nom in noms)
{
    Console.WriteLine(nom);
}

// On veut afficher les noms avec l'âge associé: on n'a pas le choix de faire appel à l'index => boucle «for»
for (int i = 0; i < noms.Length; i++)
{
    Console.WriteLine($"Nom: {noms[i]}, âge: {ages[i]}");
}
```

Comme dit en introduction, il est notamment utile de créer des tableaux pour stocker des valeurs à réutiliser plus tard.

!! Exemple 7.2c

```cs
/** Programme qui trace un graphique pour une fonction **/

int nbMin = 1;              // Nombre minimal pour lequel on désire le calcul
int nbMax = 10;             // Nombre maximal pour lequel on désire le calcul
const int intervalleX = 7;  // Intervalle de présentation des valeurs d'abscisse
const int nbColonnes = 50;  // Nombre de colonnes d'affichage du graphique
const int tailleMarge = 4;  // Taille de la marge gauche du graphique

// Un tableau qui contiendra tous les resultats de calcul
double[] resultats = new double[nbMax - nbMin + 1];

// On calcule et enregistre les résultats nbMin à nbMax, inclusivement 
for (int n = nbMin; n <= nbMax; n++)
{
    /* L'index de l'élément ayant la valeur n sera n-nbMin
      (donc, on aura resultats[0] = calcul(nbMin), resultats[1] = calcul(nbMin+1), etc.) */
    // NOTE: on peut changer le calcul ci-dessus pour n'importe quelle fonction croissant avec n
    resultats[n - nbMin] = Math.Pow(n,2);
}

// On trace un graphique de n en fonction de calcul(n) sur nbColonnes colonnes
Console.WriteLine($"{"Graphique de n en fonction de calcul(n)", nbColonnes-((nbColonnes-40)/2)}");
Console.WriteLine();
for (int i = nbMax - nbMin; i >= 0; i--)
{
    // Ramène le résultat sur une échelle de nbColonnes
    int colonne = (int)Math.Round(nbColonnes * (resultats[i] - resultats[0]) / (resultats[nbMax - nbMin] - resultats[0]));

    // On affiche la valeur de n (l'échelle des ordonnées)
    Console.Write($"{i+nbMin, -tailleMarge}");

    // On met des blancs avant de mettre le point
    for (int j = 0; j < colonne-1; j++)
    {
        Console.Write(" ");
    }

    // On met le point
    Console.WriteLine("*");
}

// On affiche l'échelle des abscisses par intervalles
Console.Write($"{" ", -tailleMarge}");
for (int col = tailleMarge; col < tailleMarge+nbColonnes; col += intervalleX)
{
    // Récupère le résultats correspondant à la colonne
    double resultat = (col-tailleMarge) * (resultats[nbMax - nbMin] - resultats[0]) / nbColonnes + resultats[0];

    // Affiche la valeur
    Console.Write($"{resultat, -intervalleX:f1}");
}

Console.WriteLine();
```