created: 20210301125750640
modified: 20210308154143667
tags: [[01 Introduction]]
title: 1.04 Petit guide de programmation
type: text/vnd.tiddlywiki

La présente section a pour but de donner des pistes de réflexion dans l'écriture d'un programme.

! Besoin

L'écriture d'un programme part généralement d'un besoin; l'identification et la compréhension du besoin est la première étape vers l'écriture d'un programme.

! Intrants et extrants

Une fois le besoin exprimé, une façon très courante et pratique de conceptualiser les programmes est sous la forme d'intrants (//input//) et de sortants (//outpout//):

[img width="900" [https://i.imgur.com/hmAlTdJ.png]]

Avant de commencer à écrire un programme, la première étape devrait donc toujours être de se demander:

# ''Quels sont les intrants?''
## Que va-t-on devoir fournir au programme comme données? Quels types (des nombres, du texte)?
## Comment va-t-on passer les données au programme? Entrée clavier à l'invite du programme? Arguments? Par un fichier?

# ''Quels sont les extrants?''
## Au final, que veut-on obtenir? Qu'est-ce qu'on veut?
## Comment récupérer les extrants? Affichage à l'écran? Enregistrement dans un fichier? Transmission par réseau?

! Les traitements

Entre les intrants et les extrants, il y a le programme et ses traitements. Savoir d'où on part (les intrants) et où on s'en va (les extrants) aide à concevoir ce qui devra être fait pour passer de l'un à l'autre, mais il n'y a pas de «recette magique» universelle, puisqu'il y a une infinité de combinaison de besoins, d'intrants et de sortants possibles.

Dans certains cas, il y a des algorithmes connus; par exemple, une formule mathématique pour convertir des °C en °F et vice-versa. Dans la vaste majorité des cas, cependant, il revient à la programmeuse ou au programmeur de penser et de créer une solution unique en utilisant les outils offerts par le langage de programmation utilisé.

Je rappellerai cependant ce qui a déjà été exprimé à la section 1.2.03, à savoir que la programmation d'un algorithme commence souvent par la décomposition des étapes mentales que l'on apliquerait si on avait juste du papier et un crayon.

<p class="boite">

!! Exemple

''Besoin:'' On désire convertir une température entrée au clavier de °C à °F , et vice versa.

# De quoi a-t-on besoin au départ?
#* la valeur de la température à convertir (un nombre), entrée au clavier à l'invite du programme
#* l'unité (°C ou °F) de la température à convertir (du texte), entrée au clavier à l'invite du programme

# Que veut-on à la fin?
#* On désire que le programme affiche à la console la valeur convertie et ses unités

# Quels traitements effectuer?
## On doit demander et stocker les intrants
##* Valeur température: type ''double'' ou ''decimal'', Console.Write() pour invite, Console.~ReadLine() + classe Convert pour lecture de l'entrée clavier
##* Unité de température: type ''string'', Console.Write() pour invite, Console.~ReadLine() pour lecture de l'entrée clavier
## On doit effectuer la conversion
##* Ici, on dispose d'une formule déjà connue, soit que °F = °C &times; 9/5 + 32 &rArr; °C = (°F - 32) &times; 5/9
##* On doit choisir la bonne formule selon les unités entrées (instruction conditionnelle)
## On affiche le résultat
##* Console.~WriteLine() pour afficher le résultat de la conversion
</p>

! La méthode de développement

Il existe diverses stratégies de planification de développement; celle que je préfère et préconise est appelée la [[méthode en spirale|https://fr.ryte.com/wiki/Mod%C3%A8le_en_spirale#Avantages.2Finconv.C3.A9nients]].

En résumé, cette méthode consiste à développer de manière itérative, c'est-à-dire à commencer avec un tout petit noyau qui compile et fonctionne, puis à ajouter des éléments et des fonctionnalités au fur et à mesure (préférentiellement en commençant le plus possible par les fonctionnalités les plus importantes), mais en s'assurant que le tout fonctionne après chaque itération, au lieu d'essayer de tout programmer d'un coup ou par paliers (p.ex., [[méthode en cascade|https://fr.ryte.com/wiki/Waterfall_model]]) et de se retrouver à la fin avec un gros programme à déboguer.

Bien que possiblement plus lente, avec la méthode spirale, on est assuré de pouvoir remettre à temps quelque-chose qui fonctionne au moins en partie, alors que c'est beaucoup moins sûr avec une méthode comme celle en cascade.

La méthode en spirale est particulièrement bien adaptée aux gros projets et s'insère notamment très bien dans un contexte [[agile|http://agilemanifesto.org/principles.html]], bien que, malheureusement, pour toutes sortes de raisons, la méthode en cascade soit encore très utilisée, notamment dans l'administration publique.

<<<

!! Exemple

Pour continuer dans l'exemple du convertisseur de température, on pourrait avoir les itérations suivantes:

# écrire un programme qui convertit une température codée dur de °C vers °F et affiche le résultat;

# modifier le programme afin d'ajouter la conversion d'une température codée dur de °F vers °C (en plus de la précédente) et affiche le résultat;

# modifier le programme afin qu'il demande les intrants, mais qu'il se contente de les afficher, sans les incorporer aux calculs;

# modifier le programme afin qu'il utilise les intrants pour effectuer seulement le calcul attendu.

Donc, à chaque itération on a un programme fonctionnel, bien qu'incomplet; le temps «perdu» est le temps de parfois devoir défaire du code écrit à une itération précédente pour attacher la nouvelle itération; p.ex., à la dernière itrération, il faudra enlever l'affichage systématique de deux calculs codés dur pour le remplacer par un affichage conditionnel, et possiblement enlever aussi ou déplacer l'affichage systématique des intrants.
<<<