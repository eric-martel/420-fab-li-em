created: 20210303151112307
modified: 20210305124925435
tags: [[07 Routines]]
title: 7.04 Les arguments
type: text/vnd.tiddlywiki

On a déjà vu comment [[passer des arguments au programme|05 Arguments de programme]] et comment ces arguments sont en fait stockés dans un tableau de chaînes passé à la fonction Main().

Comme Main() est une fonction, on comprend facilement que l'on peut certainement en fait passer des arguments à toutes les fonctions; qui plus est, alors qu'on se contentera de toujours passer un tableau de chaînes au Main(), on peut en fait passer n'importe quelle quantité et n'importe quel type d'arguments aux fonctions que l'on crée; on place les arguments entre parenthèses, et il revient à la déclaration de fonction de définir le nombre et le type d'arguments à recevoir.

Les arguments reçus par une fonction sont des variables au même titre que les autres variables de la fonction, et ne sont pas visibles de l'extérieur de la fonction.

Ainsi, par exemple, le dernier exemple de la [[section 7.03|7.03 Valeurs de retour]] aurait avant à être réécrit en utilisant des arguments:

```cs
static void Main()
{
    // Calcule des racines de nbMin à nbMax et les retourne dans un tableau
    static double[] CalculerDesRacines(int nbMin, int nbMax)
    {
        // Le tableau qui contiendra les racines
        double[] racines = new double[nbMax - nbMin + 1];

        // Calcule les racines de nbMin à nbMax
        for (int nb = nbMin; nb <= nbMax; nb++)
        {
            racines[nb - nbMin] = Math.Sqrt(nb);
        }

        return racines;
    }

    int limiteInferieure = 10;
    int limiteSuperieure = 20;

    // Reçoit les racines
    double[] racines = CalculerDesRacines(limiteInferieure, limiteSuperieure);

    // Affiche les racines
    foreach (double racine in racines)
    {
        Console.WriteLine(racine);
    }
}

```

! Passage par valeur VS passage par référence des types élémentaires

Il y a deux grandes façons de passer un argument ayant un type élémentaire (''int'', ''double'', ''decimal'', ''string'', etc.) à une fonction:

# ''Par valeur:'' la fonction récupère alors une ''copie'' de ce qui lui a été passé, de sorte que toutes les transformations faites sur l'argument reçu par la fonction resteront seulement dans la fonction; c'est la façon «de base» de passer des arguments de type élémentaire  à une fonction.<div>

```cs
// Affichera toujours 11, peu importe la valeur passée en argument
static void AfficherEntier(int entierFonction)
{
    entierFonction= 11;
    Console.WriteLine($"Entier fonction = {entierFonction}");
}

int entierProgramme = 22;
Afficher(entierProgramme );

// Affichera 22, car entierFonction est une copie de entierProgramme
Console.WriteLine($"Entier programme = {entierProgramme }");
```
</div>

# ''Par référence (ou adresse):'' plutôt que de prendre une copie de la valeur passée, la fonction récupère plutôt un «alias» sur la variable passée, ce qui, dans le cas de variables ayant de lourds contenus, est plus performant puisque l'opération de copie des valeurs n'a pas lieu.<div>

On distingue notamment trois façons de passer une valeur par référence, selon l'intention, en apposant un modificateur devant le type d'argument dans la déclaration de fonction:

# avec le modificateur ''ref'': la variable passée doit être initialisée et peut être modifiée par la fonction;
# avec le modificateur  ''out'': la variable passée n'a pas à être initialisée, mais ''doit'' être modifiée par la fonction (une sorte de valeur de retour);
# avec le modificateur  ''in'': la variable passée doit être initialisée et ne pourra être modifiée par la fonction (une sorte de constante pour la fonction).

</div>Donc, avec ''ref'' et ''out'', toutes les modifications faites à l'argument dans la fonction se réflèteront aussi sur la variable d'origine qui a été passée.<div>

```cs
static void AfficherValeurs(string mot, ref string motRef, out string motOut , in string motIn)
{
    mot = "mot";
    motRef = "motRef";
    motOut = "motOut";

    // On ne peut pas modifier motIn
    // motIn = "motIn fonction";

    Console.WriteLine($"Fonction: {mot}, {motRef}, {motOut}, {motIn}");
}

string mot1 = "mot1";
string mot2 = "mot2";
string mot3 = "mot3";
string mot4 = "mot4";

AfficherValeurs(mot1, ref mot2, out mot3, in mot4);

Console.WriteLine($"Programme: {mot1}, {mot2}, {mot3}, {mot4}");

/* Sortie:
 * 
 * Fonction: mot, motRef, motOut, mot4
 * Programme: mot1, motRef, motOut, mot4
 * 
 */
```

Donc, ci-dessus, le contenu de mot2 et mot3 a été modifié par la fonction en raison des passages par référence ''ref'' et ''out'' permettant tous deux la modification.
</div>

<p class="boite">
D'un point de vue strictement technique, le type ''string'' est toujours passé par adresse, mais comme C# en fait automatiquement une copie pour la fonction, il se comporte au final comme les autres types de base. Vous n'avez pas à vous préoccuper de ce point: je ne le mentionne qu'à des fins de précision.
</p>